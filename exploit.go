package main

import (
	"fmt"
	"strings"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/protos/peer"
)

type SimpleAsset struct{}

// Init
func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response {
	// Get the args from the transaction proposal
	return shim.Success(nil)
}

// Invoke
func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response {
	// Extract the function and args from the transaction proposal
	fn, args := stub.GetFunctionAndParameters()

	if fn == "test" {
		fmt.Println("Testing security flaw ")
		if len(args) >= 1 {
			data, _ := stub.GetState("readToken")
			fmt.Println("ReadTokenState is " + string(data))
			if string(data) == "0" {
				stub.PutState("readToken", []byte("1"))
				if strings.Compare(string(args[0]), "a") == 0 {
					data, _ := stub.GetState("a")
					return shim.Success(data)
				} else {
					data, _ := stub.GetState("b")
					return shim.Success(data)
				}
				return shim.Success([]byte("Read Allowed"))
			}
		}
		return shim.Success([]byte("Read not allowed"))
	} else if fn == "reset" {
		stub.PutState("a", []byte("This is A's secret JNSDLJNSD"))
		stub.PutState("b", []byte("This is B's secret EREFKSNKS"))
		stub.PutState("readToken", []byte("0"))
		return shim.Success([]byte("Read completed"))
	}
	// Return the result as success payload
	return shim.Success([]byte("Success"))
}

// main function starts up the chaincode in the container during instantiate
func main() {
	if err := shim.Start(new(SimpleAsset)); err != nil {
		fmt.Printf("Error starting SimpleAsset chaincode: %s", err)
	}
}
